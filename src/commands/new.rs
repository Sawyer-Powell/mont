//! Task creation commands - creates tasks with different default types.

use std::path::{Path, PathBuf};

use owo_colors::OwoColorize;

use super::shared::{create_via_editor, make_temp_file};
use crate::error_fmt::AppError;
use crate::{GateItem, GateStatus, MontContext, Task, TaskType};

/// Arguments for creating a typed task (task, gate).
pub struct CreateArgs {
    pub title: Option<String>,
    pub description: Option<String>,
    pub before: Vec<String>,
    pub after: Vec<String>,
    pub gates: Vec<String>,
    pub editor: Option<Option<String>>,
    pub resume: Option<PathBuf>,
}

/// Create a new task with type 'task'.
pub fn task(ctx: &MontContext, args: CreateArgs) -> Result<(), AppError> {
    create_typed(ctx, args, TaskType::Task)
}

/// Create a new task with type 'gate'.
pub fn gate(ctx: &MontContext, args: CreateArgs) -> Result<(), AppError> {
    create_typed(ctx, args, TaskType::Gate)
}

/// Create a new task with the specified type.
fn create_typed(
    ctx: &MontContext,
    args: CreateArgs,
    task_type: TaskType,
) -> Result<(), AppError> {
    // Resume mode: re-open a temp file from a previous failed validation
    if let Some(temp_path) = args.resume {
        let editor_name = args.editor.flatten();
        return resume_from_temp(ctx, &temp_path, editor_name.as_deref(), task_type);
    }

    // Title is required when not resuming
    let Some(title) = args.title else {
        return Err(AppError::IdOrTitleRequired);
    };

    // Build a Task with empty id (will be generated)
    let task = Task {
        id: String::new(), // Will be generated by MontContext::insert()
        title: Some(title),
        description: args.description.unwrap_or_default(),
        before: args.before,
        after: args.after,
        gates: args
            .gates
            .into_iter()
            .map(|id| GateItem {
                id,
                status: GateStatus::Pending,
            })
            .collect(),
        task_type,
        status: None,
        deleted: false,
    };

    // Editor mode: create temp file, open editor, validate on save
    if let Some(editor_opt) = args.editor {
        let editor_name = editor_opt.as_deref();
        return create_with_editor(ctx, &task, editor_name);
    }

    // Non-editor mode: insert directly
    let task_id = ctx.insert(task)?;

    let file_path = ctx.tasks_dir().join(format!("{}.md", task_id));
    print_created(&file_path, task_type);

    Ok(())
}

fn create_with_editor(
    ctx: &MontContext,
    task: &Task,
    editor_name: Option<&str>,
) -> Result<(), AppError> {
    let type_name = match task.task_type {
        TaskType::Task => "task",
        TaskType::Gate => "gate",
        TaskType::Jot => "jot",
    };
    let path = make_temp_file(type_name, std::slice::from_ref(task), None)?;

    run_editor_workflow(ctx, &path, editor_name, task.task_type)
}

fn resume_from_temp(
    ctx: &MontContext,
    temp_path: &Path,
    editor_name: Option<&str>,
    task_type: TaskType,
) -> Result<(), AppError> {
    if !temp_path.exists() {
        return Err(AppError::TempFileNotFound(temp_path.display().to_string()));
    }

    run_editor_workflow(ctx, temp_path, editor_name, task_type)
}

fn run_editor_workflow(
    ctx: &MontContext,
    path: &Path,
    editor_name: Option<&str>,
    task_type: TaskType,
) -> Result<(), AppError> {
    let created_ids = create_via_editor(ctx, path, editor_name)?;

    if created_ids.is_empty() {
        println!("No tasks defined, aborting.");
        return Ok(());
    }

    for task_id in &created_ids {
        let file_path = ctx.tasks_dir().join(format!("{}.md", task_id));
        print_created(&file_path, task_type);
    }

    Ok(())
}

fn print_created(file_path: &Path, task_type: TaskType) {
    let path_str = file_path.display().to_string();
    match task_type {
        TaskType::Task => println!("{} {}", "created:".bright_green(), path_str.bright_green()),
        TaskType::Gate => println!("{} {}", "created:".bright_red(), path_str.bright_red()),
        TaskType::Jot => println!("{} {}", "created:".yellow(), path_str.yellow()),
    }
}
