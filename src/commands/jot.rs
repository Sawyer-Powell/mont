//! Jot command - quickly jot down an idea (creates a task with type 'jot').

use std::path::{Path, PathBuf};

use owo_colors::OwoColorize;

use super::shared::{create_via_editor, make_temp_file};
use crate::error_fmt::AppError;
use crate::{MontContext, Task, TaskType, ValidationItem, ValidationStatus};

/// Arguments for creating a jot.
pub struct JotArgs {
    pub title: Option<String>,
    pub description: Option<String>,
    pub before: Vec<String>,
    pub after: Vec<String>,
    pub validations: Vec<String>,
    pub editor: Option<Option<String>>,
    pub resume: Option<PathBuf>,
}

/// Create a new jot (quick idea capture).
pub fn jot(ctx: &MontContext, args: JotArgs) -> Result<(), AppError> {
    // Resume mode: re-open a temp file from a previous failed validation
    if let Some(temp_path) = args.resume {
        let editor_name = args.editor.flatten();
        return resume_from_temp(ctx, &temp_path, editor_name.as_deref());
    }

    // Title is required when not resuming
    let Some(title) = args.title else {
        return Err(AppError::IdOrTitleRequired);
    };

    // Build a Task with type: jot and empty id (will be generated)
    let task = Task {
        id: String::new(), // Will be generated by MontContext::insert()
        title: Some(title),
        description: args.description.unwrap_or_default(),
        before: args.before,
        after: args.after,
        validations: args
            .validations
            .into_iter()
            .map(|id| ValidationItem {
                id,
                status: ValidationStatus::Pending,
            })
            .collect(),
        task_type: TaskType::Jot,
        status: None,
        deleted: false,
    };

    // Editor mode: create temp file, open editor, validate on save
    if let Some(editor_opt) = args.editor {
        let editor_name = editor_opt.as_deref();
        return create_with_editor(ctx, &task, editor_name);
    }

    // Non-editor mode: insert directly
    let task_id = ctx.insert(task)?;

    let file_path = ctx.tasks_dir().join(format!("{}.md", task_id));
    println!(
        "{} {}",
        "created:".yellow(),
        file_path.display().to_string().yellow()
    );

    Ok(())
}

fn create_with_editor(
    ctx: &MontContext,
    task: &Task,
    editor_name: Option<&str>,
) -> Result<(), AppError> {
    let path = make_temp_file("jot", std::slice::from_ref(task), None)?;

    run_editor_workflow(ctx, &path, editor_name)
}

fn resume_from_temp(
    ctx: &MontContext,
    temp_path: &Path,
    editor_name: Option<&str>,
) -> Result<(), AppError> {
    if !temp_path.exists() {
        return Err(AppError::TempFileNotFound(temp_path.display().to_string()));
    }

    run_editor_workflow(ctx, temp_path, editor_name)
}

fn run_editor_workflow(
    ctx: &MontContext,
    path: &Path,
    editor_name: Option<&str>,
) -> Result<(), AppError> {
    let created_ids = create_via_editor(ctx, path, editor_name)?;

    if created_ids.is_empty() {
        println!("No tasks defined, aborting.");
        return Ok(());
    }

    for task_id in &created_ids {
        let file_path = ctx.tasks_dir().join(format!("{}.md", task_id));
        println!(
            "{} {}",
            "created:".yellow(),
            file_path.display().to_string().yellow()
        );
    }

    Ok(())
}
